# -*- coding: utf-8 -*-
"""
mpltools.py
A bag of tools to be used in processing and interpreting MPL class data
collected by miniMPL
Created on Wed Apr 24 12:08:57 2013

@author: Paul Cottle

"""

import numpy as np
import os,sys

def set_dir(titlestring):
    from Tkinter import Tk
    import tkFileDialog
     
     
    master = Tk()
    master.withdraw() #hiding tkinter window
     
    file_path = tkFileDialog.askdirectory(title=titlestring)
     
    if file_path != "":
       return str(file_path)
     
    else:
       print "you didn't open anything!"
     
def get_files(titlestring,filetype = ('.txt','*.txt')):
    from Tkinter import Tk
    import tkFileDialog
     
     
    master = Tk()
    master.withdraw() #hiding tkinter window

    file_path = []
     
    file_path = tkFileDialog.askopenfilename(title=titlestring, filetypes=[filetype,("All files",".mpl")],multiple='True')
     
    if file_path != "":
       return str(file_path)
     
    else:
       print "you didn't open anything!"
       
def quicklook(MPLdat, vlim = []):
    import matplotlib.pyplot as plt
    from matplotlib.colors import Normalize
    from matplotlib import cm

    
    copol = MPLdat.data[0]
    crosspol = MPLdat.data[1]
    
    print 'Copol Shape is'
    print np.shape(copol)
    print 'Crosspol Shape is'
    print np.shape(crosspol)
    
    cmap = cm.jet
    
    if vlim:
        cmap.set_over('r')
        cmap.set_under('k')
        vmin= vlim[0]
        vmax= vlim[1]
        the_norm=Normalize(vmin=vmin,vmax=vmax,clip=False)
        fig = plt.figure()
        ax1 = fig.add_subplot(121)
        im1 = ax1.pcolormesh(copol.values.T,cmap=cmap,norm=the_norm)
        cb = fig.colorbar(im1,extend='both')
    
        ax2 = fig.add_subplot(122)
        im2 = ax2.pcolormesh(crosspol.values.T,cmap=cmap,norm=the_norm)
        cb = fig.colorbar(im1,extend='both')
    else:
        fig = plt.figure()
        ax1 = fig.add_subplot(121)
        im1 = ax1.pcolormesh(copol.values.T,cmap=cmap)
        cb = fig.colorbar(im1,extend='both')
    
        ax2 = fig.add_subplot(122)
        im2 = ax2.pcolormesh(crosspol.values.T,cmap=cmap)
        cb = fig.colorbar(im1,extend='both')
    
    plt.show()

def alt_resample(MPLdat, altrange):
    #takes a pandas dataframe generated by mplreader and resamples on regular
    #intervals in altitude and resets the limits of the set
    #note: limits of altrange must be within original limits of altitude data
    import numpy as np
    import pandas as pan       
    from scipy.interpolate import interp1d
    
    dataout = np.empty(MPLdat.header.numchans, dtype = object)
    for n in range(MPLdat.header.numchans):
        print 'Altitude step resampling in progress ...'
        df = MPLdat.data[n]
        x = df.columns
        
        numrows = np.size(df.index)
        numcols = np.size(altrange)
    
        newvalues = np.empty([numrows, numcols])
        r = 0
    
        for row in df.iterrows():
            f = interp1d(x,row[1].values)
            newvalues[r,:] = f(altrange)
            r += 1
        dataout[n] = pan.DataFrame(data = newvalues, index = df.index, columns = altrange)
        print '... Done!'
        
    MPLdat.data = dataout
    return MPLdat

def time_resample(MPLdat, timestep, timerange = False, s_mode = 'mean'):
    #resamples a pandas dataframe generated by mplreader on a regular timestep
    #and optionally limits it to a preset time range
    #timestep must be in timeseries period format: numF where num=step size and
    #F = offset alias.  Ex: H = hours, M = minutes, S = seconds, L = millieconds
    import pandas as pan
    
    dataout = np.empty(2, dtype=object)
    for n in range(MPLdat.header.numchans):    
        print 'Time step regularization in progress ...'
        df = MPLdat.data[n]
        if timerange:
            start_time = timerange[0]
            end_time = timerange[1]
    
            dfout = df[(df.index>=start_time) & (df.index<=end_time)]
    
        dataout[n] = dfout.resample(timestep, how = s_mode)
    
        print '... Done!'
        
    MPLdat.data = dataout
    return MPLdat
    
def background_subtract(MPLdat):
    import numpy as np
    import pandas as pan
    
    backbins = MPLdat.header.backbins
          
    dataout = []
    for n in range(MPLdat.header.numchans):
        df = MPLdat.data[n]

        newvalues = np.empty_like(df.values)
        
        r = 0
        for row in df.iterrows():
            bg = np.mean(row[1].values[-backbins:])
            newvalues[r,:] = np.array(row[1].values - bg)
            r += 1
        
        dataout.append(pan.DataFrame(data = newvalues, index = df.index, columns = df.columns))
    
    MPLdat.data = dataout   
    return MPLdat

def range_cor(MPLdat):
    import numpy as np
    import pandas as pan
       
    dataout = []
    for n in [0,1]:
        df = MPLdat.data[n]
        rsq = np.array(df.columns, dtype=float)**2
        newvalues = np.empty_like(df.values)
        r = 0
        for row in df.iterrows():
            newvalues[r,:] = row[1].values*rsq
            r += 1
        
        dataout.append(pan.DataFrame(data = newvalues, index = df.index, columns = df.columns))
    
    MPLdat.data = dataout    
    return MPLdat  



class MPL:
    """
    This is a class type generated by unpacking a binary file generated by
    the mini-MPL lidar
    
    It includes two subclasses: header and data
    The metadata in the header is described in the MPL manual pp 37-38
    The data consists of a 2-D array of floats separated into channels
    
    copol = data measured in laser polarization
    crosspol = data measured in cross polarization
    
    """
    
    def __init__(self):
        
        self.data = [] #slot for lidar data array
        
        class header:
            def __init__(self):
                self.unitnum = []
                self.version = []
                self.datetime = []
                self.shotsum = []  #total number of shots collected per profile
                self.trigfreq = [] #laser trigger frequency (usually 2500 Hz)
                self.energy = [] #mean of laser energy monitor in uJ
                self.temp_0 = []  #mean of A/D#0 readings*100
                self.temp_1 = []  #mean of A/D#1 readings*100
                self.temp_2 = []  #mean of A/D#2 readings*100
                self.temp_3 = []  #mean of A/D#3 readings*100
                self.temp_4 = []  #mean of A/D#4 readings*100
                
                self.bg_avg1 = [] #mean background signal value for channel 1
                self.bg_std1 = [] #standard deviation of backgruond signal for channel 1

                self.numchans = [] #number of channels
                self.numbins = [] #total number of bins per channel

                self.bintime = []  #bin width in seconds
                
                self.rangecal = [] #range offset in meters, default is 0

                self.databins = []  #number of bins not including those used for background
                self.scanflag = []  #0: no scanner, 1: scanner
                self.backbins = []  #number of background bins

                self.az = []  #scanner azimuth angle
                self.el = []  #scanner elevation angle
                self.deg = [] #compass degrees (currently unused)
                self.pvolt0 = [] #currently unused
                self.pvolt1 = [] #currently unused
                self.gpslat = [] #GPS latitude in decimal degreees (-999.0 if no GPS)
                self.gpslon = []#GPS longitude in decimal degrees (-999.0 if no GPS)
                self.cloudbase = [] #cloud base height in [m]

                self.baddat = []  #0: good data, 1: bad data
                self.version = [] #version of file format.  current version is 1

                self.bg_avg2 = [] #mean background signal for channel 2
                self.bg_std2 = [] #mean background standard deviation for channel 2

                self.mcs = []  #MCS mode register  Bit#7: 0-normal, 1-polarization
                                             #Bit#6-5: polarization toggling: 00-linear polarizer control
                                             #01-toggling pol control, 10-toggling pol control 11-circular pol control

                self.firstbin = []  #bin # of first return data
                self.systype = []   #0: standard MPL, 1: mini MPL
                self.syncrate = []  #mini-MPL only, sync pulses seen per second
                self.firstback = [] #mini-MPL only, first bin used for background calcs
                self.headersize2 = [] #size of additional header data (currently unused)
        
        self.header = header()
    
    def fromfile(self, filename):
        import numpy as np
        import array
        import datetime as dt
        import pandas as pan
        from scipy import constants as const
        
        binfile = open(filename,'rb')
        
        intarray16 = array.array('H')
        intarray32 = array.array('L')
        floatarray = array.array('f')
        byte_array = array.array('B')
        datavals = array.array('f')
        
        
        intarray16.fromfile(binfile, 8)
        intarray32.fromfile(binfile, 8)
        floatarray.fromfile(binfile, 2)
        intarray16.fromfile(binfile, 1)
        intarray32.fromfile(binfile, 1)
        floatarray.fromfile(binfile, 2)
        intarray16.fromfile(binfile, 3)
        floatarray.fromfile(binfile, 8)
        byte_array.fromfile(binfile, 2)
        floatarray.fromfile(binfile, 2)
        byte_array.fromfile(binfile, 1)
        intarray16.fromfile(binfile, 1)
        byte_array.fromfile(binfile, 1)
        intarray16.fromfile(binfile, 3)
                   
        self.header.unitnum = intarray16[0]
        self.header.version = intarray16[1]
        year = intarray16[2]
        month = intarray16[3]
        day = intarray16[4]
        hour = intarray16[5]
        minute = intarray16[6]
        second = intarray16[7]

        self.header.datetime = dt.datetime(year,month,day,hour,minute,second)

        self.header.shotsum = intarray32[0]  #total number of shots collected per profile
        self.header.trigfreq = intarray32[1] #laser trigger frequency (usually 2500 Hz)
        self.header.energy = intarray32[2]/1000.0  #mean of laser energy monitor in uJ
        self.header.temp_0 = intarray32[3]/1000.0  #mean of A/D#0 readings*100
        self.header.temp_1 = intarray32[4]/1000.0  #mean of A/D#1 readings*100
        self.header.temp_2 = intarray32[5]/1000.0  #mean of A/D#2 readings*100
        self.header.temp_3 = intarray32[6]/1000.0  #mean of A/D#3 readings*100
        self.header.temp_4 = intarray32[7]/1000.0  #mean of A/D#4 readings*100
        
        self.header.bg_avg1 = floatarray[0] #mean background signal value for channel 1
        self.header.bg_std1 = floatarray[1] #standard deviation of backgruond signal for channel 1

        self.header.numchans = intarray16[8] #number of channels
        self.header.numbins = intarray32[8] #total number of bins per channel

        self.header.bintime = floatarray[2]  #bin width in seconds
        
        self.header.rangecal = floatarray[3] #range offset in meters, default is 0

        self.header.databins = intarray16[9]  #number of bins not including those used for background
        self.header.scanflag = intarray16[10]  #0: no scanner, 1: scanner
        self.header.backbins = intarray16[11]  #number of background bins

        self.header.az = floatarray[4]  #scanner azimuth angle
        self.header.el = floatarray[5]  #scanner elevation angle
        self.header.deg = floatarray[6] #compass degrees (currently unused)
        self.header.pvolt0 = floatarray[7] #currently unused
        self.header.pvolt1 = floatarray[8] #currently unused
        self.header.gpslat = floatarray[9] #GPS latitude in decimal degreees (-999.0 if no GPS)
        self.header.gpslon = floatarray[10]#GPS longitude in decimal degrees (-999.0 if no GPS)
        self.header.cloudbase = floatarray[11] #cloud base height in [m]

        self.header.baddat = byte_array[0]  #0: good data, 1: bad data
        self.header.version = byte_array[1] #version of file format.  current version is 1

        self.header.bg_avg2 = floatarray[12] #mean background signal for channel 2
        self.header.bg_std2 = floatarray[13] #mean background standard deviation for channel 2

        self.header.mcs = byte_array[2]  #MCS mode register  Bit#7: 0-normal, 1-polarization
                                     #Bit#6-5: polarization toggling: 00-linear polarizer control
                                     #01-toggling pol control, 10-toggling pol control 11-circular pol control

        self.header.firstbin = intarray16[12]  #bin # of first return data
        self.header.systype = byte_array[3]   #0: standard MPL, 1: mini MPL
        self.header.syncrate = intarray16[13]  #mini-MPL only, sync pulses seen per second
        self.header.firstback = intarray16[14] #mini-MPL only, first bin used for background calcs
        self.header.headersize2 = intarray16[15] #size of additional header data (currently unused)
        
        firstbin = self.header.firstbin            
        numbins = self.header.numbins
        numchans = self.header.numchans          
        
        while True:
            try:
                datavals.fromfile(binfile,(numbins*numchans))                    
            except EOFError:
                break
            
        altstep = self.header.bintime*const.c #altitude step in meters
        maxalt = numbins*altstep
        minalt = self.header.rangecal
        altrange = np.arange(minalt,maxalt,altstep,dtype='float')
        
        timestep = dt.timedelta(seconds = self.header.shotsum/self.header.trigfreq) #time between profiles in seconds
        dt = self.header.datetime
      
        if numchans == 2:
            
            profdat_copol = []
            profdat_crosspol = []
            
            n = 0
            itermax = 4*numbins
            while n < len(datavals):
                profdat_crosspol.append(datavals[n:n+numbins]) 
                n += numbins                               
                profdat_copol.append(datavals[n:n+numbins])
                
                n += numbins + 32
                
                #note: this more adaptive algorithm should have worked
                #I'm not sure why it doesn't so I'm going with the
                #patch for now - 04-25-13
#                            m = n+numbins
#                            temp_prof_crosspol = datarray[n:m]
#                            temp_prof_copol = datarray[m:m+numbins]
#                            
#                            
#                            if all(temp_prof_crosspol > 1e-6):                             
#                                profdat_crosspol.append(temp_prof_crosspol)                                
#                                profdat_copol.append(temp_prof_copol)
#                                n += 2*numbins
#                            else:
#                                n += 1
            copoldat = np.array(profdat_copol)
            crosspoldat = np.array(profdat_crosspol)
            numsteps = np.shape(copoldat)[0]

            timerange = []
            for t in range(0,numsteps):
                timerange.append(dt)
                dt += timestep  
                
            self.data = [pan.DataFrame(copoldat,index = timerange,columns = altrange),\
            pan.DataFrame(crosspoldat,index = timerange,columns = altrange)]
            
        else:
            raise ValueError('Wrong number of channels')
        
        return self
    
    
    def copy(self):
        from copy import deepcopy
        
        MPLout = MPL()
        MPLout = deepcopy(self)
        
        return MPLout
    
    def append(self,MPLnew):
        
        if not self.header.datetime:
            self.header = MPLnew.header
        for n in range(self.header.numchans):
            self.data[n] = self.data[n].append(MPLnew.data[n])
        
        return self

    


    
    